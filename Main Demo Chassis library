
    
#define RIGHT 0 
#define LEFT 3
#define ninetyDeg 460000
#define oneEighty 930000
#define fortyFive 232500
#define ticksPerCm 12
#define yellow 0
#define red 1
#define blue 2

//line following 
int rSpeed;
int lSpeed;
//square up
int lftDone = 0;
int rghtDone = 0;
int squareDone = 0;
//cameracode
int blobArea;
int blobAvg;
int blobCount = 0;
int blobRaw = 0;
//callibrate gyros
int gyroCounter = 0;
int gyroMass = 0;
int gyroAvg;
int gyroBias;
//turning 
float theta;
float targetTheta;
//gyroStraight
int target;
int driveCorrection;
//center on color 
int centerCorrection;


/* this line follow code is made in a way in wich it sees all the grey values between as well so if it sees a 
dark grey it will turn harder than if it saw a light grey*/

void lineFollow(int dist,int port){

    cmpc(0);
    cmpc(3);

    while(gmpc(RIGHT) + gmpc(LEFT)/2  < dist){



        rSpeed = -1* analog(port) + 3000; // I used a graph to get how hard it would turn and these are the slope functions
        lSpeed = analog(0) - 200;

        mav(0,lSpeed - 500);
        mav(3,rSpeed - 500);


    }
}


// uses two sensors to line up on a black line 
void squareUp(int speed){

    while(squareDone == 0){
        if(analog(2) < 3600){
            mav(LEFT,speed);
            rghtDone = 1;
        }else{
            mav(LEFT,0);
            rghtDone = 0;
        }
        if(analog(3) < 3500){
            mav(RIGHT,speed);
            lftDone = 1;
        }else{
            mav(RIGHT,0);
            lftDone = 0;
        }
        if(lftDone == 0 && rghtDone == 0){
            squareDone = 1;
        }
    }

}


//checks to see if a certain port senses black
int analogIsBlack(int port){

    if(analog(port) > 2500){
        return(1);
    }else{
        return(0);
    }
}








//main color code for detecting color
int colorSense(int color, int loops) {
    
	camera_open_black();
    
  while(blobCount < loops){

    camera_update();
    if(color == 0){
      if(get_object_confidence(yellow,0) > 0.6){
        blobRaw = blobRaw + 1;
      } 
    }

    if(color == 1){
      if(get_object_confidence(blue,0) > 0.6){
        blobRaw = blobRaw + 1; 
      }
    }

    if(color == 2){
      if(get_object_confidence(red,0) > 0.6){
        blobRaw = blobRaw + 1; 
      }
      
    }
    blobCount = blobCount + 1;
    
  }

  
  
  if(blobRaw > 70){
    return 0;
  }else{
    return 1;
  }
  
}






// callibraes the bias of the gyros
void callibrateGyros(){
    
     while(gyroCounter < 1000){
    	
        gyroMass = gyroMass + gyro_z();
        gyroCounter++;
        msleep(1);
    }
    
    gyroAvg = (gyroMass / 1000);
    printf("average Z value: %d \n", gyroAvg);
    gyroBias = gyroAvg;
    
}

//uses the gyroscopes to make turns
void gyroTurn(int R,int L,int turnDeg){
    
    callibrateGyros();
    if(turnDeg == 90){
        targetTheta = ninetyDeg;
    }
    if(turnDeg == 45){
        targetTheta = fortyFive;
    }
    if(turnDeg == 180){
        targetTheta = oneEighty;
    }
    
     while(theta < targetTheta){
        msleep(10);
        theta = theta + (abs(gyro_z() - gyroBias) * 10);
        mav(RIGHT,R);
        mav(LEFT,L);
    }
                 
    mav(3,0);
    mav(0,0);  
    msleep(1000);
    
}

//uses the gyroscopes to drive straight 
void gyroStraight(int dist,int speed){

    cmpc(0);
    cmpc(3);
    
   callibrateGyros();
    
    while(gmpc(RIGHT) < 15000){
        
        driveCorrection = 200;
  
        if(theta < 250 && theta > -250){ 
            mav(RIGHT,speed);
            mav(LEFT,speed);
        }else if(theta < 250){
            mav(RIGHT,speed + driveCorrection);
            mav(LEFT,speed - driveCorrection);
        }else{
            mav(RIGHT,speed - driveCorrection);
            mav(LEFT,speed + driveCorrection);
        }
            
            msleep(10);
            theta = theta+(gyro_z() - gyroBias)*10;
        }
        
}

//simple servo command
void servo(int port, int pos){
    
    enable_servos();
    set_servo_position(port,pos);
    msleep(1000);
    disable_servos();
    
}



//has the robot line itself up with the color you select
void centerOnColor(int channel){
    
    camera_open_black();
    
    centerCorrection = 200;
    while(get_object_center_x(channel,0) != 80){ 
        
        camera_update();
        
        if(get_object_center_x(channel,0) < 80){
            mav(RIGHT,centerCorrection);
            mav(LEFT,-centerCorrection);
        }
        if(get_object_center_x(channel,0) > 80){
            mav(RIGHT,-centerCorrection);
            mav(LEFT, centerCorrection);
        }
    }
    
    camera_close();
}

// untested
void driveIntoBlack(int initSpeed, int slowDown){
    while(analogIsBlack(0) == 1){
        mav(RIGHT,initSpeed);
        mav(LEFT,initSpeed);
    }
    if(analogIsBlack(0) == 0){
        squareUp(initSpeed - slowDown);
    }
}
            
    
    
